# STAT.Stamina — 스태미나 시스템 (Why)
- 목표: 모든 스태미나 소모/회복을 **비동기 + 프레임 분산** 규칙으로 처리하고, 외부 시스템과는 **간접 통신**만으로 결합한다.
- 결과: 어떤 프로젝트에서도 동일 규칙으로 플러그인화하여 안전하게 통합 가능.

```yaml
# ------ Machine-Readable Contract (What) ------
pluginContract:
  pluginName: STAT          # 플러그인 접두어(3~4자 대문자)
  version: "1.2.0"
  dependencies: []          # 다른 플러그인을 C++로 직접 참조하지 않는다 (격리 원칙)
  exposes:                  # C++은 '노출만', 최종 조립은 BP에서 수행
    - type: UInterface
      name: ISTAT_StaminaOwner_If
    - type: EventDispatcher
      name: STAT_OnStaminaChanged_E
    - type: DataAsset
      name: DA_STAT_AttributeSet

feature:
  featureName: StaminaSystem
  description: "이벤트 기반 비동기 파이프라인으로 스태미나 소모/회복을 처리, GameThread 적용은 1ms 이하 Time-Slice 규칙으로 분산"
  tags: [Stat.Core, Stat.Resource.Stamina]

io:
  inputs:
    - name: ConsumeStaminaRequested
      kind: MessageBus
      payload:
        Caster: Actor
        Amount: float
        CauseTag: name
    - name: RestoreStaminaRequested
      kind: MessageBus
      payload:
        Caster: Actor
        Amount: float
        CauseTag: name
  outputs:
    - name: STAT_OnStaminaChanged_E
      kind: EventDispatcher
      payload:
        Owner: Actor
        Prev: float
        Cur: float
        Delta: float
        Max: float
        CauseTag: name

pipeline:
  - step: EnqueueConsumeRequests
    where: ThreadPool                  # 비동기 수집
    builder:
      name: "STAT.EnqueueConsume"
      priority: Normal
      timeout_ms: 5000
      cancel_token: true
      trace_tag: "STAT.Consume.Enqueue"
    batch:                             # 동종 요청을 프레임 말미에 일괄 처리
      key: "ConsumeStamina"
      flush: frame_end

  - step: ApplyBatchedConsume
    where: GameThread_TimeSliced       # GameThread에서만, 1ms 이하 분할
    time_slice_ms: 1
    guardrails:
      weak_capture: true               # SAFE_WEAK_LAMBDA
      require_game_thread: true
      trace_tag: "STAT.Consume.Apply"
    effects:
      - mutate: "Stamina -= Sum(Amount)"
      - emit: "STAT_OnStaminaChanged_E"

  - step: EnqueueRestoreRequests
    where: ThreadPool
    builder:
      name: "STAT.EnqueueRestore"
      priority: Low
      timeout_ms: 5000
      cancel_token: true
      trace_tag: "STAT.Restore.Enqueue"
    batch:
      key: "RestoreStamina"
      flush: frame_end

  - step: ApplyBatchedRestore
    where: GameThread_TimeSliced
    time_slice_ms: 1
    guardrails:
      weak_capture: true
      require_game_thread: true
      trace_tag: "STAT.Restore.Apply"
    effects:
      - mutate: "Stamina += Sum(Amount)"
      - emit: "STAT_OnStaminaChanged_E"

nonNegotiableRules:    # 절대 준수 규칙(문서의 최종 검증 항목과 동일)
  - AlwaysGameThreadForUObject
  - WeakLambdaForAsyncCallbacks
  - StepLe1ms_TimeSlicedOnGT
  - TimeoutAndCancellation
  - TraceTagEveryTask

components:            # Z1 불변 코어 구성요소 사용 선언
  use:
    - FGameTaskManager
    - FPriorityTaskQueue
    - FTimeSlicedTask
    - TFuture
    - FBatchProcessor

tests:
  - id: "TST-STAT-Perf-01"
    type: perf
    command: "RunUnrealTest --map STAT_Test.umap --case StaminaPerf"
    acceptance:
      fps_avg_min: 60
      max_spike_ms: 2

  - id: "TST-STAT-Functional-01"
    type: functional
    command: "RunUnrealTest --map STAT_Test.umap --case ConsumeAndRestore"
    acceptance:
      event_payload_match: true
      preview_equals_apply: true

traceability:          # (선택) 커널 스키마와 연결해 요구–산출–테스트를 묶을 수 있음
  requirements: ["REQ-STAT-001", "REQ-STAT-002"]
  artifacts:
    - id: "ART-STAT-VM"
      type: blueprint
      path: "Plugins/STAT/Content/UI/WBP_Status.umg"
  links:
    - { from: "REQ-STAT-001", to: "TST-STAT-Functional-01", type: REQ_TEST }
    - { from: "REQ-STAT-001", to: "ART-STAT-VM",           type: REQ_IMPL }
```

